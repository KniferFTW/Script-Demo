'use strict';

exports.__esModule = true;
exports.createList = exports.unquote = exports.trimChar = exports.createCharGrabber = undefined;

var _char = require('@bbob/plugin-helper/lib/char');

/**
 * @typedef {Object} CharGrabber
 * @property {Function} skip
 * @property {Function} hasNext
 * @property {Function} isLast
 * @property {Function} grabWhile
 */

/**
 * Creates a grabber wrapper for source string, that helps to iterate over string char by char
 * @param {String} source
 * @param {Object} options
 * @param {Function} options.onSkip
 * @returns
 */
var createCharGrabber = exports.createCharGrabber = function createCharGrabber(source, options) {
  // let idx = 0;
  var cursor = {
    pos: 0,
    length: source.length
  };

  var skip = function skip() {
    cursor.pos += 1;

    if (options && options.onSkip) {
      options.onSkip();
    }
  };
  var hasNext = function hasNext() {
    return cursor.length > cursor.pos;
  };
  var getRest = function getRest() {
    return source.substr(cursor.pos);
  };
  var getCurr = function getCurr() {
    return source[cursor.pos];
  };

  return {
    skip: skip,
    hasNext: hasNext,
    isLast: function isLast() {
      return cursor.pos === cursor.length;
    },
    /**
     * @param {Function} cond
     * @returns {string}
     */
    grabWhile: function grabWhile(cond) {
      var start = 0;

      if (hasNext()) {
        start = cursor.pos;

        while (hasNext() && cond(getCurr())) {
          skip();
        }
      }

      return source.substr(start, cursor.pos - start);
    },
    getNext: function getNext() {
      return source[cursor.pos + 1];
    },
    getPrev: function getPrev() {
      return source[cursor.pos - 1];
    },
    getCurr: getCurr,
    getRest: getRest,
    /**
     * Grabs rest of string until it find a char
     * @param {String} char
     * @return {String}
     */
    substrUntilChar: function substrUntilChar(char) {
      var restStr = getRest();
      var indexOfChar = restStr.indexOf(char);

      if (indexOfChar >= 0) {
        return restStr.substr(0, indexOfChar);
      }

      return '';
    }
  };
};

/**
 * Trims string from start and end by char
 * @example
 *  trimChar('*hello*', '*') ==> 'hello'
 * @param {String} str
 * @param {String} charToRemove
 * @returns {String}
 */
var trimChar = exports.trimChar = function trimChar(str, charToRemove) {
  while (str.charAt(0) === charToRemove) {
    // eslint-disable-next-line no-param-reassign
    str = str.substring(1);
  }

  while (str.charAt(str.length - 1) === charToRemove) {
    // eslint-disable-next-line no-param-reassign
    str = str.substring(0, str.length - 1);
  }

  return str;
};

/**
 * Unquotes \" to "
 * @param str
 * @return {String}
 */
var unquote = exports.unquote = function unquote(str) {
  return str.replace(_char.BACKSLASH + _char.QUOTEMARK, _char.QUOTEMARK);
};

/**
 * @typedef {Object} ItemList
 * @type {Object}
 * @property {getLastCb} getLast
 * @property {flushLastCb} flushLast
 * @property {pushCb} push
 * @property {toArrayCb} toArray
 */

/**
 *
 * @param values
 * @return {ItemList}
 */
var createList = exports.createList = function createList() {
  var values = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

  var nodes = values;
  /**
   * @callback getLastCb
   */
  var getLast = function getLast() {
    return nodes.length ? nodes[nodes.length - 1] : null;
  };
  /**
   * @callback flushLastCb
   * @return {*}
   */
  var flushLast = function flushLast() {
    if (nodes.length) {
      return nodes.pop();
    }

    return false;
  };
  /**
   * @callback pushCb
   * @param value
   */
  var push = function push(value) {
    return nodes.push(value);
  };

  /**
   * @callback toArrayCb
   * @return {Array}
   */

  return {
    getLast: getLast,
    flushLast: flushLast,
    push: push,
    toArray: function toArray() {
      return nodes;
    }
  };
};